<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dante's Rings: The Dream World Journey</title>
    
    <link rel="apple-touch-icon" href="Dante_App_Logo.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <style>
        /* --- 1. GLOBAL STYLES & BRANDING --- */
        :root { 
            --roblox-blue: #00A2FF; 
            --roblox-green: #00E676; 
            --candy-pink: #FF1493; 
            --candy-yellow: #FFD700;
            --ui-bg-panel: rgba(0, 0, 0, 0.75);
            --text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background: #000 url('Roblox_Bg.jpg') no-repeat center center fixed; 
            background-size: cover; color: white; 
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; 
            touch-action: none; 
            display: flex; flex-direction: column; align-items: center; 
            height: 100vh; width: 100vw;
            transition: background 1.5s ease-in-out;
        }

        /* --- 2. DECORATIVE SKY ELEMENTS --- */
        .cloud { 
            position: absolute; background: rgba(255, 255, 255, 0.8); 
            border-radius: 10px; z-index: 1; pointer-events: none; 
        }
        @keyframes drift { 
            from { transform: translateX(-400px); } 
            to { transform: translateX(120vw); } 
        }

        /* --- 3. THE HUD (TOP BAR) --- */
        #ui-header { 
            height: 12vh; width: 100%; display: flex; 
            flex-direction: column; justify-content: center; align-items: center; 
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(15px); 
            z-index: 100; border-bottom: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        /* --- 4. GAMEPLAY CONTAINER (73% HEIGHT) --- */
        #main-layout { 
            display: flex; flex: 1; width: 100%; 
            justify-content: center; align-items: center; gap: 15px; 
            position: relative; z-index: 50; padding: 10px; box-sizing: border-box;
        }

        .sidebar { 
            display: flex; flex-direction: column; justify-content: center; 
            align-items: center; gap: 15px; width: 18vw; max-width: 90px; 
        }
        .sidebar-label { font-size: 11px; font-weight: 900; letter-spacing: 1px; }

        .box { 
            background: var(--ui-bg-panel); border: 4px solid #FFF; 
            border-radius: 20px; width: 75px; height: 75px; 
            display: flex; align-items: center; justify-content: center; 
            position: relative; box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.4); 
        }

        /* --- 5. DANTE AVATAR ANIMATION --- */
        #dante-avatar-container { 
            position: absolute; top: -75px; left: 5px; width: 65px; height: 65px; 
            transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            z-index: 200;
        }
        #dante-avatar-container img { 
            width: 100%; height: 100%; object-fit: contain; 
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.5)); 
        }

        /* --- 6. THE GRID (STRETCH-PROOF RATIO) --- */
        #game-container { 
            position: relative; height: 98%; aspect-ratio: 10 / 20; 
            border: 6px solid #FFF; border-radius: 30px; 
            background: rgba(0, 0, 0, 0.45); overflow: hidden; 
            box-shadow: 15px 15px 0px rgba(0, 0, 0, 0.4);
            display: flex; align-items: center; justify-content: center;
        }
        canvas#tetris { width: 100%; height: 100%; display: block; }

        /* --- 7. PROGRESSION HUD --- */
        #progress-container { 
            width: 75%; height: 16px; background: rgba(255,255,255,0.2); 
            border: 3px solid #FFF; border-radius: 12px; 
            margin: 8px auto; overflow: hidden; 
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }
        #progress-fill { 
            width: 0%; height: 100%; background: var(--roblox-green); 
            box-shadow: 0 0 20px var(--roblox-green); 
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
        }

        /* --- 8. CONTROLS (BOTTOM BAR) --- */
        .bottom-bar { 
            display: flex; gap: 30px; padding: 15px; 
            height: 15vh; width: 100%; justify-content: center; 
            align-items: center; background: rgba(0, 0, 0, 0.5); 
            box-sizing: border-box; z-index: 100;
        }
        .action-btn { 
            width: 110px; height: 80px; border-radius: 22px; 
            border: 5px solid #FFF; background: var(--roblox-blue); 
            font-size: 34px; color: white; box-shadow: 0 8px 0px #0077be; 
            cursor: pointer; display: flex; justify-content: center; align-items: center;
        }
        .action-btn:active { transform: translateY(4px); box-shadow: 0 4px 0px #0077be; }

        /* --- 9. FULL-SCREEN OVERLAYS --- */
        #start-overlay, #game-overlay { 
            position: absolute; inset: 0; background: var(--roblox-blue); 
            display: flex; flex-direction: column; align-items: center; 
            justify-content: center; z-index: 1000; text-align: center; padding: 40px; 
        }
        .overlay-btn { 
            padding: 22px 55px; background: var(--roblox-green); color: white; 
            border: 6px solid white; border-radius: 60px; font-size: 32px; 
            font-weight: bold; cursor: pointer; box-shadow: 0 10px 0px #009624; 
            margin-top: 25px; text-transform: uppercase;
        }
        .overlay-btn:active { transform: translateY(4px); box-shadow: 0 6px 0px #009624; }
        
        #win-prize-image { 
            width: 250px; margin-bottom: 25px; display: none; 
            border-radius: 25px; box-shadow: 0 20px 40px rgba(0,0,0,0.6); 
            border: 4px solid white;
        }
        
        #mute-btn { 
            position: absolute; top: 20px; right: 20px; width: 55px; height: 55px; 
            background: rgba(255, 255, 255, 0.3); border: 3px solid #FFF; 
            border-radius: 50%; display: flex; align-items: center; 
            justify-content: center; z-index: 1100; font-size: 28px; cursor: pointer; 
        }
    </style>
</head>

<body onpointerdown="handleSystemAudioWakup()">

    <div id="mute-btn" onclick="toggleGlobalMute()">ðŸ”Š</div>

    <div class="cloud" style="width:180px; height:60px; top:15%; animation: drift 42s linear infinite;"></div>
    <div class="cloud" style="width:240px; height:80px; top:42%; animation: drift 58s linear reverse infinite;"></div>

    <div id="start-overlay">
        <img src="Dante_App_Logo.png" style="width:180px; margin-bottom:25px; filter: drop-shadow(6px 6px 0px rgba(0,0,0,0.3));">
        <h1 style="font-size: 52px; margin: 0; text-shadow: 5px 5px 0px rgba(0,0,0,0.3);">DANTE'S RINGS</h1>
        <p style="font-size: 22px; margin: 10px 0 30px 0;">Unlock the Future Vibrant Self</p>
        <button class="overlay-btn" onclick="initiateGameSession()">START ADVENTURE</button>
    </div>

    <div id="ui-header">
        <b id="world-title-label" style="font-size: 26px; text-transform: uppercase; color: var(--roblox-blue);">Underwater World</b>
        <div style="font-size: 20px; margin: 5px 0; color: white;">SCORE: <span id="game-score">0</span> | LINES: <span id="game-lines">0</span></div>
        <div id="progress-container"><div id="progress-fill"></div></div>
    </div>
    
    <div id="main-layout">
        <div class="sidebar">
            <span class="sidebar-label">HOLD</span>
            <div class="box">
                <div id="dante-avatar-container"><img src="Dante_App_Logo.png" id="dante-img"></div>
                <canvas id="hold-canvas" width="50" height="50"></canvas>
            </div>
        </div>

        <div id="game-container">
            <canvas id="tetris" width="200" height="400"></canvas>
            
            <div id="game-overlay" style="display:none; background: rgba(0, 0, 0, 0.96);">
                <img id="win-prize-image" src="Youwin.png">
                <h2 id="msg-overlay-title" style="font-size: 38px; margin: 15px 0; color: var(--roblox-blue);">PAUSED</h2>
                <p id="msg-overlay-text" style="font-size:20px; max-width:340px; line-height: 1.5; margin: 15px 0; color: white;"></p>
                <button class="overlay-btn" id="msg-overlay-btn" onclick="executeOverlayAction()">CONTINUE</button>
            </div>
        </div>

        <div class="sidebar">
            <span class="sidebar-label">NEXT</span>
            <div class="box"><canvas id="next-canvas" width="50" height="50"></canvas></div>
        </div>
    </div>

    <div class="bottom-bar">
        <button class="action-btn" onpointerdown="handlePieceHold()" title="Hold Ring">ðŸ“¦</button>
        <button class="action-btn" onpointerdown="handlePieceRotate()" title="Spin Ring">ðŸ”„</button>
    </div>

<script>
/**
 * ============================================================================
 * DANTE'S RINGS: THE CORE ENGINE
 * ============================================================================
 * Explicit verification:
 * - iPhone/iPad Aspect locking [Active]
 * - .m4a Soundtrack Support [Active]
 * - Roblox Atmosphere Sync [Active]
 * - Hello Kitty Visual Logic [Active]
 */

// --- I. CORE CONSTANTS & DOM ---
const gameGrid = document.getElementById('tetris');
const gameCtx = gameGrid.getContext('2d');
const holdCanvas = document.getElementById('hold-canvas');
const holdCtx = holdCanvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextCtx = nextCanvas.getContext('2d');

const overlayBox = document.getElementById('game-overlay');
const overlayTitle = document.getElementById('msg-overlay-title');
const overlayText = document.getElementById('msg-overlay-text');
const overlayBtn = document.getElementById('msg-overlay-btn');
const winnerLogo = document.getElementById('win-prize-image');

const progMeterFill = document.getElementById('progress-fill');
const danteSpriteBox = document.getElementById('dante-avatar-container');
const worldNameHeader = document.getElementById('world-title-label');

const COLS = 10;
const ROWS = 20;
const BLOCK = 20;

// Initialize Scaling
gameCtx.scale(BLOCK, BLOCK); 
holdCtx.scale(12, 12); 
nextCtx.scale(12, 12);

// --- II. AUDIO ARCHITECTURE (.M4A VERIFIED) ---
const audioCtxInstance = new (window.AudioContext || window.webkitAudioContext)();
const mainSoundtrack = new Audio('Dantesgamemusic.m4a');
mainSoundtrack.loop = true; 
mainSoundtrack.volume = 0.45;

let audioSystemReady = false;
let isAudioMuted = false;

function handleSystemAudioWakup() {
    if (!audioSystemReady) {
        if (audioCtxInstance.state === 'suspended') {
            audioCtxInstance.resume();
        }
        audioSystemReady = true;
    }
}

function toggleGlobalMute() {
    isAudioMuted = !isAudioMuted;
    mainSoundtrack.muted = isAudioMuted;
    document.getElementById('mute-btn').innerText = isAudioMuted ? 'ðŸ”‡' : 'ðŸ”Š';
}

/**
 * Procedural SFX generation
 */
function triggerBeep(freq, wave, duration) {
    if (isAudioMuted || !audioSystemReady) return;
    
    const osc = audioCtxInstance.createOscillator();
    const gain = audioCtxInstance.createGain();
    
    osc.type = wave;
    osc.frequency.setValueAtTime(freq, audioCtxInstance.currentTime);
    
    gain.gain.setValueAtTime(0.08, audioCtxInstance.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtxInstance.currentTime + duration);
    
    osc.connect(gain);
    gain.connect(audioCtxInstance.destination);
    
    osc.start();
    osc.stop(audioCtxInstance.currentTime + duration);
}

// --- III. STORYBOARD & LEVEL PARAMETERS ---
const ringLessons = [
    "Underwater: Dante learns to breathe beneath the surface of his feelings.",
    "Pandora: Curiosity opens new colors in Dante's sky.",
    "Minecraft: Dante discovers he can rebuild any pattern he breaks.",
    "Lego World: Dante plays with structure instead of fearing it.",
    "Rainforest: Dante trusts growth he cannot yet see.",
    "Outer Space: Dante finds stillness in the vast unknown.",
    "Jungle: Dante follows instinct, moving piece by piece.",
    "School: Dante realizes every mis-drop is a lesson.",
    "Sun Surface: Dante holds his shape even in the heat.",
    "Dream World: Dante wakes up inside his own imagination."
];

const adventureLevels = [
    { name: "Underwater World", bg: "rgba(0, 168, 255, 0.4)", target: 30, speed: 1000 },
    { name: "Pandora", bg: "rgba(106, 13, 173, 0.4)", target: 60, speed: 900 },
    { name: "Minecraft", bg: "rgba(124, 252, 0, 0.4)", target: 90, speed: 820 },
    { name: "Legoworld", bg: "rgba(255, 0, 0, 0.4)", target: 120, speed: 750 },
    { name: "Rainforest", bg: "rgba(0, 100, 0, 0.4)", target: 150, speed: 680 },
    { name: "Outer Space", bg: "rgba(0, 0, 34, 0.6)", target: 180, speed: 600 },
    { name: "Jungle", bg: "rgba(34, 139, 34, 0.4)", target: 210, speed: 520 },
    { name: "School", bg: "rgba(47, 79, 79, 0.4)", target: 240, speed: 450 },
    { name: "Sun Surface", bg: "rgba(255, 69, 0, 0.4)", target: 270, speed: 380 },
    { name: "Dream World", bg: "rgba(255, 182, 193, 0.5)", target: 350, speed: 320 }
];

// --- IV. PIECE DEFINITIONS (STORY RINGS) ---
const pieceColors = [
    null, 
    '#FF1493', // 1: Hello Kitty Pink
    '#FFD700', // 2: Hello Kitty Yellow
    '#A020F0', // 3: Pandora Purple
    '#00E5FF', // 4: Sky Cyan
    '#FF4500', // 5: Sun Orange
    '#39FF14', // 6: Jungle Green
    '#FF0000'  // 7: School Red
];

/**
 * Creates the physical matrix for each ring shape
 */
function createPieceMatrix(type) {
    if (type === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
    if (type === 'L') return [[0,2,0],[0,2,0],[0,2,2]];
    if (type === 'J') return [[0,3,0],[0,3,0],[3,3,0]];
    if (type === 'O') return [[4,4],[4,4]];
    if (type === 'Z') return [[5,5,0],[0,5,5],[0,0,0]];
    if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
    if (type === 'T') return [[0,7,0],[7,7,7],[0,0,0]];
}

// --- V. ENGINE STATE & INITIALIZATION ---
const gridArena = Array.from({length: ROWS}, () => Array(COLS).fill(0));
const playerState = { pos: {x: 0, y: 0}, matrix: null, score: 0 };

let nextPieceMatrix = null;
let heldPieceMatrix = null;
let holdAvailable = true;
let linesClearedCount = 0;
let worldIndex = 0;

let isGamePaused = true;
let dropTimer = 0;
let lastTimestamp = 0;
let activeDropInterval = 1000;

function initiateGameSession() {
    handleSystemAudioWakup();
    document.getElementById('start-overlay').style.display = 'none';
    completeReset();
}

function completeReset() {
    gridArena.forEach(row => row.fill(0));
    linesClearedCount = 0; 
    playerState.score = 0; 
    worldIndex = 0;
    heldPieceMatrix = null; 
    nextPieceMatrix = null;
    activeDropInterval = adventureLevels[0].speed;
    worldNameHeader.innerText = adventureLevels[0].name;
    
    refreshHUD();
    overlayBox.style.display = 'none';
    isGamePaused = false;
    
    spawnNewPiece();
    if (!isAudioMuted) mainSoundtrack.play().catch(e => console.log("Music Playing"));
    requestAnimationFrame(mainUpdateLoop);
}

/**
 * Spawns a ring at the top row (Y=0) and centers it horizontally.
 */
function spawnNewPiece() {
    const pieces = 'ILJOTSZ';
    // 1. Spawning
    playerState.matrix = nextPieceMatrix || createPieceMatrix(pieces[Math.floor(Math.random() * pieces.length)]);
    nextPieceMatrix = createPieceMatrix(pieces[Math.floor(Math.random() * pieces.length)]);
    
    // 2. Initial Positioning (Precise top-center)
    playerState.pos.y = 0;
    playerState.pos.x = (COLS / 2 | 0) - (playerState.matrix[0].length / 2 | 0);
    
    holdAvailable = true;
    
    // 3. Collision End Check
    if (checkCollision(gridArena, playerState)) {
        triggerBeep(150, 'sawtooth', 0.6);
        displayGameOverlay("STACKED OUT!", "Breathe. notice the pattern you're building. Every step is growth.", false);
    }
}

// --- VI. CORE PHYSICS LOGIC ---

function checkCollision(arena, p) {
    const [m, o] = [p.matrix, p.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                return true;
            }
        }
    }
    return false;
}

function mergePieceIntoArena(arena, p) {
    p.matrix.forEach((row, y) => row.forEach((v, x) => { 
        if (v !== 0) arena[y + p.pos.y][x + p.pos.x] = v; 
    }));
}

/**
 * Scans arena for full rows and triggers Dante Jump animation.
 */
function processArenaSweep() {
    let clearedRows = 0;
    for (let y = gridArena.length - 1; y >= 0; --y) {
        if (gridArena[y].every(cell => cell !== 0)) {
            gridArena.splice(y, 1);
            gridArena.unshift(new Array(COLS).fill(0));
            clearedRows++;
            y++; 
        }
    }
    if (clearedRows > 0) {
        linesClearedCount += clearedRows;
        playerState.score += clearedRows * 10;
        triggerBeep(523, 'sine', 0.25); 
        refreshHUD();
        
        // DANTE JUMP TRIGGER
        danteSpriteBox.style.transform = 'scale(1.5) translateY(-25px)';
        setTimeout(() => danteSpriteBox.style.transform = 'scale(1) translateY(0)', 250);
    }
}

function refreshHUD() {
    document.getElementById('game-score').innerText = playerState.score;
    document.getElementById('game-lines').innerText = linesClearedCount;
    
    const theme = adventureLevels[worldIndex];
    const prevGoal = worldIndex > 0 ? adventureLevels[worldIndex - 1].target : 0;
    
    const relativeProgress = linesClearedCount - prevGoal;
    const distanceNeeded = theme.target - prevGoal;
    
    const pct = Math.max(0, Math.min(100, (relativeProgress / distanceNeeded * 100)));
    progMeterFill.style.width = pct + '%';

    // WIN CHECK (DREAM WORLD)
    if (worldIndex === adventureLevels.length - 1 && linesClearedCount >= theme.target) {
        displayGameOverlay("YOU REACHED DREAM WORLD!", "Dante climbed every ring. The Self you are rehearsing is complete.", true);
        return;
    }
    
    // LEVEL UP CHECK
    if (linesClearedCount >= theme.target && worldIndex < adventureLevels.length - 1) {
        worldIndex++;
        activeDropInterval = adventureLevels[worldIndex].speed;
        worldNameHeader.innerText = adventureLevels[worldIndex].name;
        triggerBeep(880, 'square', 0.4);
        displayGameOverlay(adventureLevels[worldIndex].name, ringLessons[worldIndex], false);
    }
}

// --- VII. OVERLAY LOGIC ---

function displayGameOverlay(title, description, isVictory) {
    isGamePaused = true; 
    mainSoundtrack.pause();
    
    overlayTitle.innerText = title;
    overlayText.innerText = description;
    winnerLogo.style.display = isVictory ? 'block' : 'none';
    
    if (isVictory) {
        overlayBtn.innerText = "PLAY AGAIN";
    } else if (title === "STACKED OUT!") {
        overlayBtn.innerText = "START AGAIN";
    } else {
        overlayBtn.innerText = "CONTINUE";
    }
    
    overlayBox.style.display = 'flex';
}

function executeOverlayAction() {
    handleSystemAudioWakup();
    if (overlayBtn.innerText === "CONTINUE") {
        overlayBox.style.display = 'none';
        isGamePaused = false;
        if (!isAudioMuted) mainSoundtrack.play();
        requestAnimationFrame(mainUpdateLoop);
    } else {
        completeReset();
    }
}

// --- VIII. TOUCH & GESTURE ENGINE (STRETCH-PROOF) ---
let touchX = 0, touchY = 0, touchMoved = false;

gameGrid.addEventListener('touchstart', e => {
    if (isGamePaused) return;
    touchX = e.touches[0].clientX;
    touchY = e.touches[0].clientY;
    touchMoved = false;
}, {passive: false});

gameGrid.addEventListener('touchmove', e => {
    if (isGamePaused) return;
    e.preventDefault(); 
    
    const curX = e.touches[0].clientX;
    const curY = e.touches[0].clientY;
    const dx = curX - touchX;
    const dy = curY - touchY;
    
    // Jitter buffer (12px)
    if (Math.abs(dx) > 12 || Math.abs(dy) > 12) touchMoved = true;

    // Tactical Drag: Horizontal Slide
    if (Math.abs(dx) > 35) {
        const dir = dx > 0 ? 1 : -1;
        playerState.pos.x += dir;
        
        if (checkCollision(gridArena, playerState)) {
            playerState.pos.x -= dir;
        } else {
            triggerBeep(400, 'sine', 0.04);
        }
        touchX = curX; 
    }
    
    // Sticky Pull: Soft Drop
    if (dy > 55) {
        activeDropInterval = 45; 
    }
}, {passive: false});

gameGrid.addEventListener('touchend', () => {
    if (!isGamePaused && !touchMoved) {
        handlePieceRotate(); // Intentional tap spins
    }
    if (!isGamePaused) {
        activeDropInterval = adventureLevels[worldIndex].speed;
    }
});

// --- IX. ROTATION & PIECE MGMT ---

function handlePieceHold() {
    if (!holdAvailable || isGamePaused) return;
    
    if (!heldPieceMatrix) {
        heldPieceMatrix = playerState.matrix;
        spawnNewPiece();
    } else {
        const tmp = playerState.matrix;
        playerState.matrix = heldPieceMatrix;
        heldPieceMatrix = tmp;
        playerState.pos.y = 0;
        playerState.pos.x = (COLS / 2 | 0) - (playerState.matrix[0].length / 2 | 0);
    }
    holdAvailable = false;
    triggerBeep(300, 'sine', 0.12);
}

function handlePieceRotate() {
    const originalX = playerState.pos.x;
    let push = 1;
    
    // Matrix Rotation logic
    for (let y = 0; y < playerState.matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [playerState.matrix[x][y], playerState.matrix[y][x]] = [playerState.matrix[y][x], playerState.matrix[x][y]];
        }
    }
    playerState.matrix.forEach(row => row.reverse());
    
    // Wall Kick Mechanism
    while (checkCollision(gridArena, playerState)) {
        playerState.pos.x += push;
        push = -(push + (push > 0 ? 1 : -1));
        if (push > 4) {
            // Undo if stuck
            playerState.matrix.forEach(row => row.reverse());
            for (let y = 0; y < playerState.matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [playerState.matrix[x][y], playerState.matrix[y][x]] = [playerState.matrix[y][x], playerState.matrix[x][y]];
                }
            }
            playerState.pos.x = originalX;
            return;
        }
    }
    triggerBeep(600, 'sine', 0.05);
}

// --- X. RENDERING PIPELINE (HELLO KITTY LOGIC) ---

function drawBlock(ctxTarget, xPos, yPos, colorID, isGhostShadow = false) {
    ctxTarget.globalAlpha = isGhostShadow ? 0.35 : 1.0;
    const cx = xPos + 0.5;
    const cy = yPos + 0.5;
    
    // HELLO KITTY EAR DRAWING
    // Logic: Color 1 (Pink) and 2 (Yellow) get ears, but only if they are not ghost shadows.
    if (!isGhostShadow && (colorID === 1 || colorID === 2)) {
        ctxTarget.fillStyle = pieceColors[colorID];
        // Left Ear
        ctxTarget.beginPath(); 
        ctxTarget.arc(cx - 0.25, cy - 0.35, 0.15, 0, Math.PI * 2); 
        ctxTarget.fill();
        // Right Ear
        ctxTarget.beginPath(); 
        ctxTarget.arc(cx + 0.25, cy - 0.35, 0.15, 0, Math.PI * 2); 
        ctxTarget.fill();
    }
    
    // THE PHYSICAL RING
    ctxTarget.beginPath();
    ctxTarget.arc(cx, cy, 0.42, 0, Math.PI * 2);
    ctxTarget.fillStyle = pieceColors[colorID];
    ctxTarget.fill();
    ctxTarget.strokeStyle = '#FFFFFF';
    ctxTarget.lineWidth = 0.08;
    ctxTarget.stroke();
    
    ctxTarget.globalAlpha = 1.0;
}

function drawMatrix(ctxTarget, matrix, offset, asGhost = false) {
    if (!matrix) return;
    matrix.forEach((row, y) => {
        row.forEach((val, x) => {
            if (val !== 0) {
                drawBlock(ctxTarget, x + offset.x, y + offset.y, val, asGhost);
            }
        });
    });
}

function fullRender() {
    // Fill the Background with the current world's hue
    gameCtx.fillStyle = adventureLevels[worldIndex].bg;
    gameCtx.fillRect(0, 0, gameGrid.width, gameGrid.height);
    
    // Draw Baseplate Grid lines (Roblox Style)
    gameCtx.strokeStyle = "rgba(255, 255, 255, 0.15)";
    gameCtx.lineWidth = 0.03;
    for(let x = 0; x <= COLS; x++) { 
        gameCtx.beginPath(); gameCtx.moveTo(x, 0); gameCtx.lineTo(x, ROWS); gameCtx.stroke(); 
    }
    for(let y = 0; y <= ROWS; y++) { 
        gameCtx.beginPath(); gameCtx.moveTo(0, y); gameCtx.lineTo(COLS, y); gameCtx.stroke(); 
    }

    if (playerState.matrix) {
        // Draw Landed Rings
        drawMatrix(gameCtx, gridArena, {x: 0, y: 0});
        
        // Calculate & Draw Ghost Ring
        const ghost = { x: playerState.pos.x, y: playerState.pos.y };
        while (!checkCollision(gridArena, { pos: ghost, matrix: playerState.matrix })) {
            ghost.y++;
        }
        ghost.y--;
        drawMatrix(gameCtx, playerState.matrix, ghost, true);
        
        // Draw Falling Ring
        drawMatrix(gameCtx, playerState.matrix, playerState.pos);
    }
    
    // Update Sidebars
    nextCtx.clearRect(0, 0, 5, 5);
    drawMatrix(nextCtx, nextPieceMatrix, {x: 0, y: 0});
    
    holdCtx.clearRect(0, 0, 5, 5);
    if (heldPieceMatrix) {
        drawMatrix(holdCtx, heldPieceMatrix, {x: 0, y: 0});
    }
}

// --- XI. SYSTEM UPDATE LOOP ---

function mainUpdateLoop(timestamp = 0) {
    if (isGamePaused) return;
    
    const delta = timestamp - lastTimestamp;
    lastTimestamp = timestamp;
    
    dropTimer += delta;
    if (dropTimer > activeDropInterval) {
        playerState.pos.y++;
        // Collision logic
        if (checkCollision(gridArena, playerState)) {
            playerState.pos.y--;
            mergePieceIntoArena(gridArena, playerState);
            processArenaSweep();
            spawnNewPiece();
            triggerBeep(200, 'sine', 0.1);
        }
        dropTimer = 0;
    }
    
    fullRender();
    requestAnimationFrame(mainUpdateLoop);
}

// INITIAL CALL
fullRender();
console.log("System Status: Dante's Rings initialized. Ready for adventure.");
</script>
</body>
</html>
